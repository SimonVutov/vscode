{
  "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts:level3": {
    "filePath": "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts",
    "level": 3,
    "summary": "Abstraction level 3 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport * as ts from 'typescript';\nimport * as path from 'path';\n\nexport async function activate(context: vscode.ExtensionContext) {\n\n\tconst fileIndex = new class {\n\n\t\tprivate _currentRun?: Thenable<void>;\n\n\t\tprivate _disposables: vscode.Disposable[] = [];\n\n\t\tprivate readonly _index = new Map<string, vscode.Uri>();\n\n\t\tconstructor() {\n\t\t\tconst watcher = vscode.workspace.createFileSystemWatcher('**/*.ts', false, true, false);\n\t\t\tthis._disposables.push(watcher.onDidChange(e => { this._index.set(e.toString(), e); }));\n\t\t\tthis._disposables.push(watcher.onDidDelete(e => { this._index.delete(e.toString()); }));\n\t\t\tthis._disposables.push(watcher);\n\n\t\t\tthis._refresh(false);\n\t\t}\n\n\t\tdispose(): void {\n\t\t\tfor (const disposable of this._disposables) {\n\t\t\t\tdisposable.dispose();\n\t\t\t}\n\t\t\tthis._disposables = [];\n\t\t\tthis._index.clear();\n\t\t}\n\n\t\tasync all(token: vscode.CancellationToken) {\n\n\t\t\tawait Promise.race([this._currentRun, new Promise<void>(resolve => token.onCancellationRequested(resolve))]);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn Array.from(this._index.values());\n\t\t}\n\n\t\tprivate _refresh(clear: boolean) {\n\t\t\t// TODO@jrieken LATEST API! findFiles2New\n\t\t\tthis._currentRun = vscode.workspace.findFiles('src/vs/**/*.ts', '{**/node_modules/**,**/extensions/**}').then(all => {\n\t\t\t\tif (clear) {\n\t\t\t\t\tthis._index.clear();\n\t\t\t\t}\n\t\t\t\tfor (const item of all) {\n\t\t\t\t\tthis._index.set(item.toString(), item);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst selector: vscode.DocumentSelector = 'typescript';\n\n\tfunction findNodeAtPosition(document: vscode.TextDocument, node: ts.Node, position: vscode.Position): ts.Node | undefined {\n\t\tif (node.getStart() <= document.offsetAt(position) && node.getEnd() >= document.offsetAt(position)) {\n\t\t\treturn ts.forEachChild(node, child => findNodeAtPosition(document, child, position)) || node;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction findImportAt(document: vscode.TextDocument, position: vscode.Position): ts.ImportDeclaration | undefined {\n\t\tconst sourceFile = ts.createSourceFile(document.fileName, document.getText(), ts.ScriptTarget.Latest, true);\n\t\tconst node = findNodeAtPosition(document, sourceFile, position);\n\t\tif (node && ts.isStringLiteral(node) && ts.isImportDeclaration(node.parent)) {\n\t\t\treturn node.parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tconst completionProvider = new class implements vscode.CompletionItemProvider {\n\t\tasync provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): Promise<vscode.CompletionList | undefined> {\n\n\t\t\tconst index = document.getText().lastIndexOf(' from \\'');\n\t\t\tif (index < 0 || document.positionAt(index).line < position.line) {\n\t\t\t\t// line after last import is before position\n\t\t\t\t// -> no completion, safe a parse call\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst node = findImportAt(document, position);\n\t\t\tif (!node) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst range = new vscode.Range(document.positionAt(node.moduleSpecifier.pos), document.positionAt(node.moduleSpecifier.end));\n\t\t\tconst uris = await fileIndex.all(token);\n\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CompletionList();\n\t\t\tresult.isIncomplete = true;\n\n\t\t\tfor (const item of uris) {\n\n\t\t\t\tif (!item.path.endsWith('.ts')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path);\n\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\tconst label = path.basename(item.path, path.extname(item.path));\n\t\t\t\tconst insertText = ` '${relativePath.replace(/\\.ts$/, '.js')}'`;\n\t\t\t\tconst filterText = ` '${label}'`;\n\n\t\t\t\tconst completion = new vscode.CompletionItem({\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tdescription: vscode.workspace.asRelativePath(item),\n\t\t\t\t});\n\t\t\t\tcompletion.kind = vscode.CompletionItemKind.File;\n\t\t\t\tcompletion.insertText = insertText;\n\t\t\t\tcompletion.filterText = filterText;\n\t\t\t\tcompletion.range = range;\n\n\t\t\t\tresult.items.push(completion);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tclass ImportCodeActions implements vscode.CodeActionProvider {\n\n\t\tstatic FixKind = vscode.CodeActionKind.QuickFix.append('esmImport');\n\n\t\tstatic SourceKind = vscode.CodeActionKind.SourceFixAll.append('esmImport');\n\n\t\tasync provideCodeActions(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tif (context.only && ImportCodeActions.SourceKind.intersects(context.only)) {\n\t\t\t\treturn this._provideFixAll(document, context, token);\n\t\t\t}\n\n\t\t\treturn this._provideFix(document, range, context, token);\n\t\t}\n\n\t\tprivate async _provideFixAll(document: vscode.TextDocument, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tconst diagnostics = context.diagnostics\n\t\t\t\t.filter(d => d.code === 2307)\n\t\t\t\t.sort((a, b) => b.range.start.compareTo(a.range.start));\n\n\t\t\tif (diagnostics.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CodeAction(`Fix All ESM Imports`, ImportCodeActions.SourceKind);\n\t\t\tresult.edit = new vscode.WorkspaceEdit();\n\t\t\tresult.diagnostics = [];\n\n\t\t\tfor (const diag of diagnostics) {\n\n\t\t\t\tconst actions = this._provideFixesForDiag(document, diag, uris);\n\n\t\t\t\tif (actions.length === 0) {\n\t\t\t\t\tconsole.log(`ESM: no fixes for \"${diag.message}\"`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (actions.length > 1) {\n\t\t\t\t\tconsole.log(`ESM: more than one fix for \"${diag.message}\", taking first`);\n\t\t\t\t\tconsole.log(actions);\n\t\t\t\t}\n\n\t\t\t\tconst [first] = actions;\n\t\t\t\tresult.diagnostics.push(diag);\n\n\t\t\t\tfor (const [uri, edits] of first.edit!.entries()) {\n\t\t\t\t\tresult.edit.set(uri, edits);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// console.log(result.edit.get(document.uri));\n\t\t\treturn [result];\n\t\t}\n\n\t\tprivate async _provideFix(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst diag = context.diagnostics.find(d => d.code === 2307 && d.range.intersection(range));\n\t\t\treturn diag && this._provideFixesForDiag(document, diag, uris);\n\t\t}\n\n\t\tprivate _provideFixesForDiag(document: vscode.TextDocument, diag: vscode.Diagnostic, uris: Iterable<vscode.Uri>): vscode.CodeAction[] {\n\n\t\t\tconst node = findImportAt(document, diag.range.start)?.moduleSpecifier;\n\t\t\tif (!node || !ts.isStringLiteral(node)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst nodeRange = new vscode.Range(document.positionAt(node.pos), document.positionAt(node.end));\n\t\t\tconst name = path.basename(node.text, path.extname(node.text));\n\n\t\t\tconst result: vscode.CodeAction[] = [];\n\n\t\t\tfor (const item of uris) {\n\t\t\t\tif (path.basename(item.path, path.extname(item.path)) === name) {\n\t\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path).replace(/\\.ts$/, '.js');\n\t\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\t\tconst action = new vscode.CodeAction(`Fix to '${relativePath}'`, ImportCodeActions.FixKind);\n\t\t\t\t\taction.edit = new vscode.WorkspaceEdit();\n\t\t\t\t\taction.edit.replace(document.uri, nodeRange, ` '${relativePath}'`);\n\t\t\t\t\taction.diagnostics = [diag];\n\t\t\t\t\tresult.push(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcontext.subscriptions.push(fileIndex);\n\tcontext.subscriptions.push(vscode.languages.registerCompletionItemProvider(selector, completionProvider));\n\tcontext.subscriptions.push(vscode.languages.registerCodeActionsProvider(selector, new ImportCodeActions(), { providedCodeActionKinds: [ImportCodeActions.FixKind, ImportCodeActions.SourceKind] }));\n}\n",
    "contentHash": "741e59394bfc5410",
    "timestamp": 1757742288666
  },
  "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts:level2": {
    "filePath": "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts",
    "level": 2,
    "summary": "Abstraction level 2 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport * as ts from 'typescript';\nimport * as path from 'path';\n\nexport async function activate(context: vscode.ExtensionContext) {\n\n\tconst fileIndex = new class {\n\n\t\tprivate _currentRun?: Thenable<void>;\n\n\t\tprivate _disposables: vscode.Disposable[] = [];\n\n\t\tprivate readonly _index = new Map<string, vscode.Uri>();\n\n\t\tconstructor() {\n\t\t\tconst watcher = vscode.workspace.createFileSystemWatcher('**/*.ts', false, true, false);\n\t\t\tthis._disposables.push(watcher.onDidChange(e => { this._index.set(e.toString(), e); }));\n\t\t\tthis._disposables.push(watcher.onDidDelete(e => { this._index.delete(e.toString()); }));\n\t\t\tthis._disposables.push(watcher);\n\n\t\t\tthis._refresh(false);\n\t\t}\n\n\t\tdispose(): void {\n\t\t\tfor (const disposable of this._disposables) {\n\t\t\t\tdisposable.dispose();\n\t\t\t}\n\t\t\tthis._disposables = [];\n\t\t\tthis._index.clear();\n\t\t}\n\n\t\tasync all(token: vscode.CancellationToken) {\n\n\t\t\tawait Promise.race([this._currentRun, new Promise<void>(resolve => token.onCancellationRequested(resolve))]);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn Array.from(this._index.values());\n\t\t}\n\n\t\tprivate _refresh(clear: boolean) {\n\t\t\t// TODO@jrieken LATEST API! findFiles2New\n\t\t\tthis._currentRun = vscode.workspace.findFiles('src/vs/**/*.ts', '{**/node_modules/**,**/extensions/**}').then(all => {\n\t\t\t\tif (clear) {\n\t\t\t\t\tthis._index.clear();\n\t\t\t\t}\n\t\t\t\tfor (const item of all) {\n\t\t\t\t\tthis._index.set(item.toString(), item);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst selector: vscode.DocumentSelector = 'typescript';\n\n\tfunction findNodeAtPosition(document: vscode.TextDocument, node: ts.Node, position: vscode.Position): ts.Node | undefined {\n\t\tif (node.getStart() <= document.offsetAt(position) && node.getEnd() >= document.offsetAt(position)) {\n\t\t\treturn ts.forEachChild(node, child => findNodeAtPosition(document, child, position)) || node;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction findImportAt(document: vscode.TextDocument, position: vscode.Position): ts.ImportDeclaration | undefined {\n\t\tconst sourceFile = ts.createSourceFile(document.fileName, document.getText(), ts.ScriptTarget.Latest, true);\n\t\tconst node = findNodeAtPosition(document, sourceFile, position);\n\t\tif (node && ts.isStringLiteral(node) && ts.isImportDeclaration(node.parent)) {\n\t\t\treturn node.parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tconst completionProvider = new class implements vscode.CompletionItemProvider {\n\t\tasync provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): Promise<vscode.CompletionList | undefined> {\n\n\t\t\tconst index = document.getText().lastIndexOf(' from \\'');\n\t\t\tif (index < 0 || document.positionAt(index).line < position.line) {\n\t\t\t\t// line after last import is before position\n\t\t\t\t// -> no completion, safe a parse call\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst node = findImportAt(document, position);\n\t\t\tif (!node) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst range = new vscode.Range(document.positionAt(node.moduleSpecifier.pos), document.positionAt(node.moduleSpecifier.end));\n\t\t\tconst uris = await fileIndex.all(token);\n\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CompletionList();\n\t\t\tresult.isIncomplete = true;\n\n\t\t\tfor (const item of uris) {\n\n\t\t\t\tif (!item.path.endsWith('.ts')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path);\n\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\tconst label = path.basename(item.path, path.extname(item.path));\n\t\t\t\tconst insertText = ` '${relativePath.replace(/\\.ts$/, '.js')}'`;\n\t\t\t\tconst filterText = ` '${label}'`;\n\n\t\t\t\tconst completion = new vscode.CompletionItem({\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tdescription: vscode.workspace.asRelativePath(item),\n\t\t\t\t});\n\t\t\t\tcompletion.kind = vscode.CompletionItemKind.File;\n\t\t\t\tcompletion.insertText = insertText;\n\t\t\t\tcompletion.filterText = filterText;\n\t\t\t\tcompletion.range = range;\n\n\t\t\t\tresult.items.push(completion);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tclass ImportCodeActions implements vscode.CodeActionProvider {\n\n\t\tstatic FixKind = vscode.CodeActionKind.QuickFix.append('esmImport');\n\n\t\tstatic SourceKind = vscode.CodeActionKind.SourceFixAll.append('esmImport');\n\n\t\tasync provideCodeActions(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tif (context.only && ImportCodeActions.SourceKind.intersects(context.only)) {\n\t\t\t\treturn this._provideFixAll(document, context, token);\n\t\t\t}\n\n\t\t\treturn this._provideFix(document, range, context, token);\n\t\t}\n\n\t\tprivate async _provideFixAll(document: vscode.TextDocument, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tconst diagnostics = context.diagnostics\n\t\t\t\t.filter(d => d.code === 2307)\n\t\t\t\t.sort((a, b) => b.range.start.compareTo(a.range.start));\n\n\t\t\tif (diagnostics.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CodeAction(`Fix All ESM Imports`, ImportCodeActions.SourceKind);\n\t\t\tresult.edit = new vscode.WorkspaceEdit();\n\t\t\tresult.diagnostics = [];\n\n\t\t\tfor (const diag of diagnostics) {\n\n\t\t\t\tconst actions = this._provideFixesForDiag(document, diag, uris);\n\n\t\t\t\tif (actions.length === 0) {\n\t\t\t\t\tconsole.log(`ESM: no fixes for \"${diag.message}\"`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (actions.length > 1) {\n\t\t\t\t\tconsole.log(`ESM: more than one fix for \"${diag.message}\", taking first`);\n\t\t\t\t\tconsole.log(actions);\n\t\t\t\t}\n\n\t\t\t\tconst [first] = actions;\n\t\t\t\tresult.diagnostics.push(diag);\n\n\t\t\t\tfor (const [uri, edits] of first.edit!.entries()) {\n\t\t\t\t\tresult.edit.set(uri, edits);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// console.log(result.edit.get(document.uri));\n\t\t\treturn [result];\n\t\t}\n\n\t\tprivate async _provideFix(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst diag = context.diagnostics.find(d => d.code === 2307 && d.range.intersection(range));\n\t\t\treturn diag && this._provideFixesForDiag(document, diag, uris);\n\t\t}\n\n\t\tprivate _provideFixesForDiag(document: vscode.TextDocument, diag: vscode.Diagnostic, uris: Iterable<vscode.Uri>): vscode.CodeAction[] {\n\n\t\t\tconst node = findImportAt(document, diag.range.start)?.moduleSpecifier;\n\t\t\tif (!node || !ts.isStringLiteral(node)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst nodeRange = new vscode.Range(document.positionAt(node.pos), document.positionAt(node.end));\n\t\t\tconst name = path.basename(node.text, path.extname(node.text));\n\n\t\t\tconst result: vscode.CodeAction[] = [];\n\n\t\t\tfor (const item of uris) {\n\t\t\t\tif (path.basename(item.path, path.extname(item.path)) === name) {\n\t\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path).replace(/\\.ts$/, '.js');\n\t\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\t\tconst action = new vscode.CodeAction(`Fix to '${relativePath}'`, ImportCodeActions.FixKind);\n\t\t\t\t\taction.edit = new vscode.WorkspaceEdit();\n\t\t\t\t\taction.edit.replace(document.uri, nodeRange, ` '${relativePath}'`);\n\t\t\t\t\taction.diagnostics = [diag];\n\t\t\t\t\tresult.push(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcontext.subscriptions.push(fileIndex);\n\tcontext.subscriptions.push(vscode.languages.registerCompletionItemProvider(selector, completionProvider));\n\tcontext.subscriptions.push(vscode.languages.registerCodeActionsProvider(selector, new ImportCodeActions(), { providedCodeActionKinds: [ImportCodeActions.FixKind, ImportCodeActions.SourceKind] }));\n}\n",
    "contentHash": "741e59394bfc5410",
    "timestamp": 1757742295165
  },
  "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts:level4": {
    "filePath": "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts",
    "level": 4,
    "summary": "Abstraction level 4 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport * as ts from 'typescript';\nimport * as path from 'path';\n\nexport async function activate(context: vscode.ExtensionContext) {\n\n\tconst fileIndex = new class {\n\n\t\tprivate _currentRun?: Thenable<void>;\n\n\t\tprivate _disposables: vscode.Disposable[] = [];\n\n\t\tprivate readonly _index = new Map<string, vscode.Uri>();\n\n\t\tconstructor() {\n\t\t\tconst watcher = vscode.workspace.createFileSystemWatcher('**/*.ts', false, true, false);\n\t\t\tthis._disposables.push(watcher.onDidChange(e => { this._index.set(e.toString(), e); }));\n\t\t\tthis._disposables.push(watcher.onDidDelete(e => { this._index.delete(e.toString()); }));\n\t\t\tthis._disposables.push(watcher);\n\n\t\t\tthis._refresh(false);\n\t\t}\n\n\t\tdispose(): void {\n\t\t\tfor (const disposable of this._disposables) {\n\t\t\t\tdisposable.dispose();\n\t\t\t}\n\t\t\tthis._disposables = [];\n\t\t\tthis._index.clear();\n\t\t}\n\n\t\tasync all(token: vscode.CancellationToken) {\n\n\t\t\tawait Promise.race([this._currentRun, new Promise<void>(resolve => token.onCancellationRequested(resolve))]);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn Array.from(this._index.values());\n\t\t}\n\n\t\tprivate _refresh(clear: boolean) {\n\t\t\t// TODO@jrieken LATEST API! findFiles2New\n\t\t\tthis._currentRun = vscode.workspace.findFiles('src/vs/**/*.ts', '{**/node_modules/**,**/extensions/**}').then(all => {\n\t\t\t\tif (clear) {\n\t\t\t\t\tthis._index.clear();\n\t\t\t\t}\n\t\t\t\tfor (const item of all) {\n\t\t\t\t\tthis._index.set(item.toString(), item);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst selector: vscode.DocumentSelector = 'typescript';\n\n\tfunction findNodeAtPosition(document: vscode.TextDocument, node: ts.Node, position: vscode.Position): ts.Node | undefined {\n\t\tif (node.getStart() <= document.offsetAt(position) && node.getEnd() >= document.offsetAt(position)) {\n\t\t\treturn ts.forEachChild(node, child => findNodeAtPosition(document, child, position)) || node;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction findImportAt(document: vscode.TextDocument, position: vscode.Position): ts.ImportDeclaration | undefined {\n\t\tconst sourceFile = ts.createSourceFile(document.fileName, document.getText(), ts.ScriptTarget.Latest, true);\n\t\tconst node = findNodeAtPosition(document, sourceFile, position);\n\t\tif (node && ts.isStringLiteral(node) && ts.isImportDeclaration(node.parent)) {\n\t\t\treturn node.parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tconst completionProvider = new class implements vscode.CompletionItemProvider {\n\t\tasync provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): Promise<vscode.CompletionList | undefined> {\n\n\t\t\tconst index = document.getText().lastIndexOf(' from \\'');\n\t\t\tif (index < 0 || document.positionAt(index).line < position.line) {\n\t\t\t\t// line after last import is before position\n\t\t\t\t// -> no completion, safe a parse call\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst node = findImportAt(document, position);\n\t\t\tif (!node) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst range = new vscode.Range(document.positionAt(node.moduleSpecifier.pos), document.positionAt(node.moduleSpecifier.end));\n\t\t\tconst uris = await fileIndex.all(token);\n\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CompletionList();\n\t\t\tresult.isIncomplete = true;\n\n\t\t\tfor (const item of uris) {\n\n\t\t\t\tif (!item.path.endsWith('.ts')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path);\n\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\tconst label = path.basename(item.path, path.extname(item.path));\n\t\t\t\tconst insertText = ` '${relativePath.replace(/\\.ts$/, '.js')}'`;\n\t\t\t\tconst filterText = ` '${label}'`;\n\n\t\t\t\tconst completion = new vscode.CompletionItem({\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tdescription: vscode.workspace.asRelativePath(item),\n\t\t\t\t});\n\t\t\t\tcompletion.kind = vscode.CompletionItemKind.File;\n\t\t\t\tcompletion.insertText = insertText;\n\t\t\t\tcompletion.filterText = filterText;\n\t\t\t\tcompletion.range = range;\n\n\t\t\t\tresult.items.push(completion);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tclass ImportCodeActions implements vscode.CodeActionProvider {\n\n\t\tstatic FixKind = vscode.CodeActionKind.QuickFix.append('esmImport');\n\n\t\tstatic SourceKind = vscode.CodeActionKind.SourceFixAll.append('esmImport');\n\n\t\tasync provideCodeActions(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tif (context.only && ImportCodeActions.SourceKind.intersects(context.only)) {\n\t\t\t\treturn this._provideFixAll(document, context, token);\n\t\t\t}\n\n\t\t\treturn this._provideFix(document, range, context, token);\n\t\t}\n\n\t\tprivate async _provideFixAll(document: vscode.TextDocument, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tconst diagnostics = context.diagnostics\n\t\t\t\t.filter(d => d.code === 2307)\n\t\t\t\t.sort((a, b) => b.range.start.compareTo(a.range.start));\n\n\t\t\tif (diagnostics.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CodeAction(`Fix All ESM Imports`, ImportCodeActions.SourceKind);\n\t\t\tresult.edit = new vscode.WorkspaceEdit();\n\t\t\tresult.diagnostics = [];\n\n\t\t\tfor (const diag of diagnostics) {\n\n\t\t\t\tconst actions = this._provideFixesForDiag(document, diag, uris);\n\n\t\t\t\tif (actions.length === 0) {\n\t\t\t\t\tconsole.log(`ESM: no fixes for \"${diag.message}\"`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (actions.length > 1) {\n\t\t\t\t\tconsole.log(`ESM: more than one fix for \"${diag.message}\", taking first`);\n\t\t\t\t\tconsole.log(actions);\n\t\t\t\t}\n\n\t\t\t\tconst [first] = actions;\n\t\t\t\tresult.diagnostics.push(diag);\n\n\t\t\t\tfor (const [uri, edits] of first.edit!.entries()) {\n\t\t\t\t\tresult.edit.set(uri, edits);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// console.log(result.edit.get(document.uri));\n\t\t\treturn [result];\n\t\t}\n\n\t\tprivate async _provideFix(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst diag = context.diagnostics.find(d => d.code === 2307 && d.range.intersection(range));\n\t\t\treturn diag && this._provideFixesForDiag(document, diag, uris);\n\t\t}\n\n\t\tprivate _provideFixesForDiag(document: vscode.TextDocument, diag: vscode.Diagnostic, uris: Iterable<vscode.Uri>): vscode.CodeAction[] {\n\n\t\t\tconst node = findImportAt(document, diag.range.start)?.moduleSpecifier;\n\t\t\tif (!node || !ts.isStringLiteral(node)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst nodeRange = new vscode.Range(document.positionAt(node.pos), document.positionAt(node.end));\n\t\t\tconst name = path.basename(node.text, path.extname(node.text));\n\n\t\t\tconst result: vscode.CodeAction[] = [];\n\n\t\t\tfor (const item of uris) {\n\t\t\t\tif (path.basename(item.path, path.extname(item.path)) === name) {\n\t\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path).replace(/\\.ts$/, '.js');\n\t\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\t\tconst action = new vscode.CodeAction(`Fix to '${relativePath}'`, ImportCodeActions.FixKind);\n\t\t\t\t\taction.edit = new vscode.WorkspaceEdit();\n\t\t\t\t\taction.edit.replace(document.uri, nodeRange, ` '${relativePath}'`);\n\t\t\t\t\taction.diagnostics = [diag];\n\t\t\t\t\tresult.push(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcontext.subscriptions.push(fileIndex);\n\tcontext.subscriptions.push(vscode.languages.registerCompletionItemProvider(selector, completionProvider));\n\tcontext.subscriptions.push(vscode.languages.registerCodeActionsProvider(selector, new ImportCodeActions(), { providedCodeActionKinds: [ImportCodeActions.FixKind, ImportCodeActions.SourceKind] }));\n}\n",
    "contentHash": "741e59394bfc5410",
    "timestamp": 1757742301554
  },
  "/Users/simonvutov/Documents/vscode/src/bootstrap-import.ts:level3": {
    "filePath": "/Users/simonvutov/Documents/vscode/src/bootstrap-import.ts",
    "level": 3,
    "summary": "Abstraction level 3 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// *********************************************************************\n// *                                                                   *\n// *  We need this to redirect to node_modules from the remote-folder. *\n// *  This ONLY applies when running out of source.                   *\n// *                                                                   *\n// *********************************************************************\n\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport { promises } from 'node:fs';\nimport { join } from 'node:path';\n\n// SEE https://nodejs.org/docs/latest/api/module.html#initialize\n\nconst _specifierToUrl: Record<string, string> = {};\n\nexport async function initialize(injectPath: string): Promise<void> {\n\t// populate mappings\n\n\tconst injectPackageJSONPath = fileURLToPath(new URL('../package.json', pathToFileURL(injectPath)));\n\tconst packageJSON = JSON.parse(String(await promises.readFile(injectPackageJSONPath)));\n\n\tfor (const [name] of Object.entries(packageJSON.dependencies)) {\n\t\ttry {\n\t\t\tconst path = join(injectPackageJSONPath, `../node_modules/${name}/package.json`);\n\t\t\tlet { main } = JSON.parse(String(await promises.readFile(path)));\n\n\t\t\tif (!main) {\n\t\t\t\tmain = 'index.js';\n\t\t\t}\n\t\t\tif (!main.endsWith('.js')) {\n\t\t\t\tmain += '.js';\n\t\t\t}\n\t\t\tconst mainPath = join(injectPackageJSONPath, `../node_modules/${name}/${main}`);\n\t\t\t_specifierToUrl[name] = pathToFileURL(mainPath).href;\n\n\t\t} catch (err) {\n\t\t\tconsole.error(name);\n\t\t\tconsole.error(err);\n\t\t}\n\t}\n\n\tconsole.log(`[bootstrap-import] Initialized node_modules redirector for: ${injectPath}`);\n}\n\nexport async function resolve(specifier: string | number, context: any, nextResolve: (arg0: any, arg1: any) => any) {\n\n\tconst newSpecifier = _specifierToUrl[specifier];\n\tif (newSpecifier !== undefined) {\n\t\treturn {\n\t\t\tformat: 'commonjs',\n\t\t\tshortCircuit: true,\n\t\t\turl: newSpecifier\n\t\t};\n\t}\n\n\t// Defer to the next hook in the chain, which would be the\n\t// Node.js default resolve if this is the last user-specified loader.\n\treturn nextResolve(specifier, context);\n}\n",
    "contentHash": "b640370b92473b2a",
    "timestamp": 1757742735729
  },
  "/Users/simonvutov/Documents/vscode/src/bootstrap-fork.ts:level3": {
    "filePath": "/Users/simonvutov/Documents/vscode/src/bootstrap-fork.ts",
    "level": 3,
    "summary": "Abstraction level 3 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as performance from './vs/base/common/performance.js';\nimport { removeGlobalNodeJsModuleLookupPaths, devInjectNodeModuleLookupPath } from './bootstrap-node.js';\nimport { bootstrapESM } from './bootstrap-esm.js';\n\nperformance.mark('code/fork/start');\n\n//#region Helpers\n\nfunction pipeLoggingToParent(): void {\n\tconst MAX_STREAM_BUFFER_LENGTH = 1024 * 1024;\n\tconst MAX_LENGTH = 100000;\n\n\t/**\n\t * Prevent circular stringify and convert arguments to real array\n\t */\n\tfunction safeToString(args: ArrayLike<unknown>): string {\n\t\tconst seen: unknown[] = [];\n\t\tconst argsArray: unknown[] = [];\n\n\t\t// Massage some arguments with special treatment\n\t\tif (args.length) {\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tlet arg = args[i];\n\n\t\t\t\t// Any argument of type 'undefined' needs to be specially treated because\n\t\t\t\t// JSON.stringify will simply ignore those. We replace them with the string\n\t\t\t\t// 'undefined' which is not 100% right, but good enough to be logged to console\n\t\t\t\tif (typeof arg === 'undefined') {\n\t\t\t\t\targ = 'undefined';\n\t\t\t\t}\n\n\t\t\t\t// Any argument that is an Error will be changed to be just the error stack/message\n\t\t\t\t// itself because currently cannot serialize the error over entirely.\n\t\t\t\telse if (arg instanceof Error) {\n\t\t\t\t\tconst errorObj = arg;\n\t\t\t\t\tif (errorObj.stack) {\n\t\t\t\t\t\targ = errorObj.stack;\n\t\t\t\t\t} else {\n\t\t\t\t\t\targ = errorObj.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\targsArray.push(arg);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = JSON.stringify(argsArray, function (key, value: unknown) {\n\n\t\t\t\t// Objects get special treatment to prevent circles\n\t\t\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\t\t\tif (seen.indexOf(value) !== -1) {\n\t\t\t\t\t\treturn '[Circular]';\n\t\t\t\t\t}\n\n\t\t\t\t\tseen.push(value);\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t});\n\n\t\t\tif (res.length > MAX_LENGTH) {\n\t\t\t\treturn 'Output omitted for a large object that exceeds the limits';\n\t\t\t}\n\n\t\t\treturn res;\n\t\t} catch (error) {\n\t\t\treturn `Output omitted for an object that cannot be inspected ('${error.toString()}')`;\n\t\t}\n\t}\n\n\tfunction safeSend(arg: { type: string; severity: string; arguments: string }): void {\n\t\ttry {\n\t\t\tif (process.send) {\n\t\t\t\tprocess.send(arg);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Can happen if the parent channel is closed meanwhile\n\t\t}\n\t}\n\n\tfunction isObject(obj: unknown): boolean {\n\t\treturn typeof obj === 'object'\n\t\t\t&& obj !== null\n\t\t\t&& !Array.isArray(obj)\n\t\t\t&& !(obj instanceof RegExp)\n\t\t\t&& !(obj instanceof Date);\n\t}\n\n\tfunction safeSendConsoleMessage(severity: 'log' | 'warn' | 'error', args: string): void {\n\t\tsafeSend({ type: '__$console', severity, arguments: args });\n\t}\n\n\t/**\n\t * Wraps a console message so that it is transmitted to the renderer.\n\t *\n\t * The wrapped property is not defined with `writable: false` to avoid\n\t * throwing errors, but rather a no-op setting. See https://github.com/microsoft/vscode-extension-telemetry/issues/88\n\t */\n\tfunction wrapConsoleMethod(method: 'log' | 'info' | 'warn' | 'error', severity: 'log' | 'warn' | 'error'): void {\n\t\tObject.defineProperty(console, method, {\n\t\t\tset: () => { },\n\t\t\tget: () => function () { safeSendConsoleMessage(severity, safeToString(arguments)); },\n\t\t});\n\t}\n\n\t/**\n\t * Wraps process.stderr/stdout.write() so that it is transmitted to the\n\t * renderer or CLI. It both calls through to the original method as well\n\t * as to console.log with complete lines so that they're made available\n\t * to the debugger/CLI.\n\t */\n\tfunction wrapStream(streamName: 'stdout' | 'stderr', severity: 'log' | 'warn' | 'error'): void {\n\t\tconst stream = process[streamName];\n\t\tconst original = stream.write;\n\n\t\tlet buf = '';\n\n\t\tObject.defineProperty(stream, 'write', {\n\t\t\tset: () => { },\n\t\t\tget: () => (chunk: string | Buffer | Uint8Array, encoding: BufferEncoding | undefined, callback: ((err?: Error | undefined) => void) | undefined) => {\n\t\t\t\tbuf += chunk.toString(encoding);\n\t\t\t\tconst eol = buf.length > MAX_STREAM_BUFFER_LENGTH ? buf.length : buf.lastIndexOf('\\n');\n\t\t\t\tif (eol !== -1) {\n\t\t\t\t\tconsole[severity](buf.slice(0, eol));\n\t\t\t\t\tbuf = buf.slice(eol + 1);\n\t\t\t\t}\n\n\t\t\t\toriginal.call(stream, chunk, encoding, callback);\n\t\t\t},\n\t\t});\n\t}\n\n\t// Pass console logging to the outside so that we have it in the main side if told so\n\tif (process.env['VSCODE_VERBOSE_LOGGING'] === 'true') {\n\t\twrapConsoleMethod('info', 'log');\n\t\twrapConsoleMethod('log', 'log');\n\t\twrapConsoleMethod('warn', 'warn');\n\t\twrapConsoleMethod('error', 'error');\n\t} else {\n\t\tconsole.log = function () { /* ignore */ };\n\t\tconsole.warn = function () { /* ignore */ };\n\t\tconsole.info = function () { /* ignore */ };\n\t\twrapConsoleMethod('error', 'error');\n\t}\n\n\twrapStream('stderr', 'error');\n\twrapStream('stdout', 'log');\n}\n\nfunction handleExceptions(): void {\n\n\t// Handle uncaught exceptions\n\tprocess.on('uncaughtException', function (err) {\n\t\tconsole.error('Uncaught Exception: ', err);\n\t});\n\n\t// Handle unhandled promise rejections\n\tprocess.on('unhandledRejection', function (reason) {\n\t\tconsole.error('Unhandled Promise Rejection: ', reason);\n\t});\n}\n\nfunction terminateWhenParentTerminates(): void {\n\tconst parentPid = Number(process.env['VSCODE_PARENT_PID']);\n\n\tif (typeof parentPid === 'number' && !isNaN(parentPid)) {\n\t\tsetInterval(function () {\n\t\t\ttry {\n\t\t\t\tprocess.kill(parentPid, 0); // throws an exception if the main process doesn't exist anymore.\n\t\t\t} catch (e) {\n\t\t\t\tprocess.exit();\n\t\t\t}\n\t\t}, 5000);\n\t}\n}\n\nfunction configureCrashReporter(): void {\n\tconst crashReporterProcessType = process.env['VSCODE_CRASH_REPORTER_PROCESS_TYPE'];\n\tif (crashReporterProcessType) {\n\t\ttry {\n\t\t\t//@ts-ignore\n\t\t\tif (process['crashReporter'] && typeof process['crashReporter'].addExtraParameter === 'function' /* Electron only */) {\n\t\t\t\t//@ts-ignore\n\t\t\t\tprocess['crashReporter'].addExtraParameter('processType', crashReporterProcessType);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\t}\n}\n\n//#endregion\n\n// Crash reporter\nconfigureCrashReporter();\n\n// Remove global paths from the node module lookup (node.js only)\nremoveGlobalNodeJsModuleLookupPaths();\n\nif (process.env['VSCODE_DEV_INJECT_NODE_MODULE_LOOKUP_PATH']) {\n\tdevInjectNodeModuleLookupPath(process.env['VSCODE_DEV_INJECT_NODE_MODULE_LOOKUP_PATH']);\n}\n\n// Configure: pipe logging to parent process\nif (!!process.send && process.env['VSCODE_PIPE_LOGGING'] === 'true') {\n\tpipeLoggingToParent();\n}\n\n// Handle Exceptions\nif (!process.env['VSCODE_HANDLES_UNCAUGHT_ERRORS']) {\n\thandleExceptions();\n}\n\n// Terminate when parent terminates\nif (process.env['VSCODE_PARENT_PID']) {\n\tterminateWhenParentTerminates();\n}\n\n// Bootstrap ESM\nawait bootstrapESM();\n\n// Load ESM entry point\nawait import([`./${process.env['VSCODE_ESM_ENTRYPOINT']}.js`].join('/') /* workaround: esbuild prints some strange warnings when trying to inline? */);\n",
    "contentHash": "d22748385c8256d7",
    "timestamp": 1757742737171
  },
  "/Users/simonvutov/Documents/vscode/src/bootstrap-fork.ts:level2": {
    "filePath": "/Users/simonvutov/Documents/vscode/src/bootstrap-fork.ts",
    "level": 2,
    "summary": "Abstraction level 2 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as performance from './vs/base/common/performance.js';\nimport { removeGlobalNodeJsModuleLookupPaths, devInjectNodeModuleLookupPath } from './bootstrap-node.js';\nimport { bootstrapESM } from './bootstrap-esm.js';\n\nperformance.mark('code/fork/start');\n\n//#region Helpers\n\nfunction pipeLoggingToParent(): void {\n\tconst MAX_STREAM_BUFFER_LENGTH = 1024 * 1024;\n\tconst MAX_LENGTH = 100000;\n\n\t/**\n\t * Prevent circular stringify and convert arguments to real array\n\t */\n\tfunction safeToString(args: ArrayLike<unknown>): string {\n\t\tconst seen: unknown[] = [];\n\t\tconst argsArray: unknown[] = [];\n\n\t\t// Massage some arguments with special treatment\n\t\tif (args.length) {\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tlet arg = args[i];\n\n\t\t\t\t// Any argument of type 'undefined' needs to be specially treated because\n\t\t\t\t// JSON.stringify will simply ignore those. We replace them with the string\n\t\t\t\t// 'undefined' which is not 100% right, but good enough to be logged to console\n\t\t\t\tif (typeof arg === 'undefined') {\n\t\t\t\t\targ = 'undefined';\n\t\t\t\t}\n\n\t\t\t\t// Any argument that is an Error will be changed to be just the error stack/message\n\t\t\t\t// itself because currently cannot serialize the error over entirely.\n\t\t\t\telse if (arg instanceof Error) {\n\t\t\t\t\tconst errorObj = arg;\n\t\t\t\t\tif (errorObj.stack) {\n\t\t\t\t\t\targ = errorObj.stack;\n\t\t\t\t\t} else {\n\t\t\t\t\t\targ = errorObj.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\targsArray.push(arg);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = JSON.stringify(argsArray, function (key, value: unknown) {\n\n\t\t\t\t// Objects get special treatment to prevent circles\n\t\t\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\t\t\tif (seen.indexOf(value) !== -1) {\n\t\t\t\t\t\treturn '[Circular]';\n\t\t\t\t\t}\n\n\t\t\t\t\tseen.push(value);\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t});\n\n\t\t\tif (res.length > MAX_LENGTH) {\n\t\t\t\treturn 'Output omitted for a large object that exceeds the limits';\n\t\t\t}\n\n\t\t\treturn res;\n\t\t} catch (error) {\n\t\t\treturn `Output omitted for an object that cannot be inspected ('${error.toString()}')`;\n\t\t}\n\t}\n\n\tfunction safeSend(arg: { type: string; severity: string; arguments: string }): void {\n\t\ttry {\n\t\t\tif (process.send) {\n\t\t\t\tprocess.send(arg);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Can happen if the parent channel is closed meanwhile\n\t\t}\n\t}\n\n\tfunction isObject(obj: unknown): boolean {\n\t\treturn typeof obj === 'object'\n\t\t\t&& obj !== null\n\t\t\t&& !Array.isArray(obj)\n\t\t\t&& !(obj instanceof RegExp)\n\t\t\t&& !(obj instanceof Date);\n\t}\n\n\tfunction safeSendConsoleMessage(severity: 'log' | 'warn' | 'error', args: string): void {\n\t\tsafeSend({ type: '__$console', severity, arguments: args });\n\t}\n\n\t/**\n\t * Wraps a console message so that it is transmitted to the renderer.\n\t *\n\t * The wrapped property is not defined with `writable: false` to avoid\n\t * throwing errors, but rather a no-op setting. See https://github.com/microsoft/vscode-extension-telemetry/issues/88\n\t */\n\tfunction wrapConsoleMethod(method: 'log' | 'info' | 'warn' | 'error', severity: 'log' | 'warn' | 'error'): void {\n\t\tObject.defineProperty(console, method, {\n\t\t\tset: () => { },\n\t\t\tget: () => function () { safeSendConsoleMessage(severity, safeToString(arguments)); },\n\t\t});\n\t}\n\n\t/**\n\t * Wraps process.stderr/stdout.write() so that it is transmitted to the\n\t * renderer or CLI. It both calls through to the original method as well\n\t * as to console.log with complete lines so that they're made available\n\t * to the debugger/CLI.\n\t */\n\tfunction wrapStream(streamName: 'stdout' | 'stderr', severity: 'log' | 'warn' | 'error'): void {\n\t\tconst stream = process[streamName];\n\t\tconst original = stream.write;\n\n\t\tlet buf = '';\n\n\t\tObject.defineProperty(stream, 'write', {\n\t\t\tset: () => { },\n\t\t\tget: () => (chunk: string | Buffer | Uint8Array, encoding: BufferEncoding | undefined, callback: ((err?: Error | undefined) => void) | undefined) => {\n\t\t\t\tbuf += chunk.toString(encoding);\n\t\t\t\tconst eol = buf.length > MAX_STREAM_BUFFER_LENGTH ? buf.length : buf.lastIndexOf('\\n');\n\t\t\t\tif (eol !== -1) {\n\t\t\t\t\tconsole[severity](buf.slice(0, eol));\n\t\t\t\t\tbuf = buf.slice(eol + 1);\n\t\t\t\t}\n\n\t\t\t\toriginal.call(stream, chunk, encoding, callback);\n\t\t\t},\n\t\t});\n\t}\n\n\t// Pass console logging to the outside so that we have it in the main side if told so\n\tif (process.env['VSCODE_VERBOSE_LOGGING'] === 'true') {\n\t\twrapConsoleMethod('info', 'log');\n\t\twrapConsoleMethod('log', 'log');\n\t\twrapConsoleMethod('warn', 'warn');\n\t\twrapConsoleMethod('error', 'error');\n\t} else {\n\t\tconsole.log = function () { /* ignore */ };\n\t\tconsole.warn = function () { /* ignore */ };\n\t\tconsole.info = function () { /* ignore */ };\n\t\twrapConsoleMethod('error', 'error');\n\t}\n\n\twrapStream('stderr', 'error');\n\twrapStream('stdout', 'log');\n}\n\nfunction handleExceptions(): void {\n\n\t// Handle uncaught exceptions\n\tprocess.on('uncaughtException', function (err) {\n\t\tconsole.error('Uncaught Exception: ', err);\n\t});\n\n\t// Handle unhandled promise rejections\n\tprocess.on('unhandledRejection', function (reason) {\n\t\tconsole.error('Unhandled Promise Rejection: ', reason);\n\t});\n}\n\nfunction terminateWhenParentTerminates(): void {\n\tconst parentPid = Number(process.env['VSCODE_PARENT_PID']);\n\n\tif (typeof parentPid === 'number' && !isNaN(parentPid)) {\n\t\tsetInterval(function () {\n\t\t\ttry {\n\t\t\t\tprocess.kill(parentPid, 0); // throws an exception if the main process doesn't exist anymore.\n\t\t\t} catch (e) {\n\t\t\t\tprocess.exit();\n\t\t\t}\n\t\t}, 5000);\n\t}\n}\n\nfunction configureCrashReporter(): void {\n\tconst crashReporterProcessType = process.env['VSCODE_CRASH_REPORTER_PROCESS_TYPE'];\n\tif (crashReporterProcessType) {\n\t\ttry {\n\t\t\t//@ts-ignore\n\t\t\tif (process['crashReporter'] && typeof process['crashReporter'].addExtraParameter === 'function' /* Electron only */) {\n\t\t\t\t//@ts-ignore\n\t\t\t\tprocess['crashReporter'].addExtraParameter('processType', crashReporterProcessType);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\t}\n}\n\n//#endregion\n\n// Crash reporter\nconfigureCrashReporter();\n\n// Remove global paths from the node module lookup (node.js only)\nremoveGlobalNodeJsModuleLookupPaths();\n\nif (process.env['VSCODE_DEV_INJECT_NODE_MODULE_LOOKUP_PATH']) {\n\tdevInjectNodeModuleLookupPath(process.env['VSCODE_DEV_INJECT_NODE_MODULE_LOOKUP_PATH']);\n}\n\n// Configure: pipe logging to parent process\nif (!!process.send && process.env['VSCODE_PIPE_LOGGING'] === 'true') {\n\tpipeLoggingToParent();\n}\n\n// Handle Exceptions\nif (!process.env['VSCODE_HANDLES_UNCAUGHT_ERRORS']) {\n\thandleExceptions();\n}\n\n// Terminate when parent terminates\nif (process.env['VSCODE_PARENT_PID']) {\n\tterminateWhenParentTerminates();\n}\n\n// Bootstrap ESM\nawait bootstrapESM();\n\n// Load ESM entry point\nawait import([`./${process.env['VSCODE_ESM_ENTRYPOINT']}.js`].join('/') /* workaround: esbuild prints some strange warnings when trying to inline? */);\n",
    "contentHash": "d22748385c8256d7",
    "timestamp": 1757742739016
  },
  "/Users/simonvutov/Documents/vscode/src/bootstrap-fork.ts:level1": {
    "filePath": "/Users/simonvutov/Documents/vscode/src/bootstrap-fork.ts",
    "level": 1,
    "summary": "Abstraction level 1 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as performance from './vs/base/common/performance.js';\nimport { removeGlobalNodeJsModuleLookupPaths, devInjectNodeModuleLookupPath } from './bootstrap-node.js';\nimport { bootstrapESM } from './bootstrap-esm.js';\n\nperformance.mark('code/fork/start');\n\n//#region Helpers\n\nfunction pipeLoggingToParent(): void {\n\tconst MAX_STREAM_BUFFER_LENGTH = 1024 * 1024;\n\tconst MAX_LENGTH = 100000;\n\n\t/**\n\t * Prevent circular stringify and convert arguments to real array\n\t */\n\tfunction safeToString(args: ArrayLike<unknown>): string {\n\t\tconst seen: unknown[] = [];\n\t\tconst argsArray: unknown[] = [];\n\n\t\t// Massage some arguments with special treatment\n\t\tif (args.length) {\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tlet arg = args[i];\n\n\t\t\t\t// Any argument of type 'undefined' needs to be specially treated because\n\t\t\t\t// JSON.stringify will simply ignore those. We replace them with the string\n\t\t\t\t// 'undefined' which is not 100% right, but good enough to be logged to console\n\t\t\t\tif (typeof arg === 'undefined') {\n\t\t\t\t\targ = 'undefined';\n\t\t\t\t}\n\n\t\t\t\t// Any argument that is an Error will be changed to be just the error stack/message\n\t\t\t\t// itself because currently cannot serialize the error over entirely.\n\t\t\t\telse if (arg instanceof Error) {\n\t\t\t\t\tconst errorObj = arg;\n\t\t\t\t\tif (errorObj.stack) {\n\t\t\t\t\t\targ = errorObj.stack;\n\t\t\t\t\t} else {\n\t\t\t\t\t\targ = errorObj.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\targsArray.push(arg);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = JSON.stringify(argsArray, function (key, value: unknown) {\n\n\t\t\t\t// Objects get special treatment to prevent circles\n\t\t\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\t\t\tif (seen.indexOf(value) !== -1) {\n\t\t\t\t\t\treturn '[Circular]';\n\t\t\t\t\t}\n\n\t\t\t\t\tseen.push(value);\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t});\n\n\t\t\tif (res.length > MAX_LENGTH) {\n\t\t\t\treturn 'Output omitted for a large object that exceeds the limits';\n\t\t\t}\n\n\t\t\treturn res;\n\t\t} catch (error) {\n\t\t\treturn `Output omitted for an object that cannot be inspected ('${error.toString()}')`;\n\t\t}\n\t}\n\n\tfunction safeSend(arg: { type: string; severity: string; arguments: string }): void {\n\t\ttry {\n\t\t\tif (process.send) {\n\t\t\t\tprocess.send(arg);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Can happen if the parent channel is closed meanwhile\n\t\t}\n\t}\n\n\tfunction isObject(obj: unknown): boolean {\n\t\treturn typeof obj === 'object'\n\t\t\t&& obj !== null\n\t\t\t&& !Array.isArray(obj)\n\t\t\t&& !(obj instanceof RegExp)\n\t\t\t&& !(obj instanceof Date);\n\t}\n\n\tfunction safeSendConsoleMessage(severity: 'log' | 'warn' | 'error', args: string): void {\n\t\tsafeSend({ type: '__$console', severity, arguments: args });\n\t}\n\n\t/**\n\t * Wraps a console message so that it is transmitted to the renderer.\n\t *\n\t * The wrapped property is not defined with `writable: false` to avoid\n\t * throwing errors, but rather a no-op setting. See https://github.com/microsoft/vscode-extension-telemetry/issues/88\n\t */\n\tfunction wrapConsoleMethod(method: 'log' | 'info' | 'warn' | 'error', severity: 'log' | 'warn' | 'error'): void {\n\t\tObject.defineProperty(console, method, {\n\t\t\tset: () => { },\n\t\t\tget: () => function () { safeSendConsoleMessage(severity, safeToString(arguments)); },\n\t\t});\n\t}\n\n\t/**\n\t * Wraps process.stderr/stdout.write() so that it is transmitted to the\n\t * renderer or CLI. It both calls through to the original method as well\n\t * as to console.log with complete lines so that they're made available\n\t * to the debugger/CLI.\n\t */\n\tfunction wrapStream(streamName: 'stdout' | 'stderr', severity: 'log' | 'warn' | 'error'): void {\n\t\tconst stream = process[streamName];\n\t\tconst original = stream.write;\n\n\t\tlet buf = '';\n\n\t\tObject.defineProperty(stream, 'write', {\n\t\t\tset: () => { },\n\t\t\tget: () => (chunk: string | Buffer | Uint8Array, encoding: BufferEncoding | undefined, callback: ((err?: Error | undefined) => void) | undefined) => {\n\t\t\t\tbuf += chunk.toString(encoding);\n\t\t\t\tconst eol = buf.length > MAX_STREAM_BUFFER_LENGTH ? buf.length : buf.lastIndexOf('\\n');\n\t\t\t\tif (eol !== -1) {\n\t\t\t\t\tconsole[severity](buf.slice(0, eol));\n\t\t\t\t\tbuf = buf.slice(eol + 1);\n\t\t\t\t}\n\n\t\t\t\toriginal.call(stream, chunk, encoding, callback);\n\t\t\t},\n\t\t});\n\t}\n\n\t// Pass console logging to the outside so that we have it in the main side if told so\n\tif (process.env['VSCODE_VERBOSE_LOGGING'] === 'true') {\n\t\twrapConsoleMethod('info', 'log');\n\t\twrapConsoleMethod('log', 'log');\n\t\twrapConsoleMethod('warn', 'warn');\n\t\twrapConsoleMethod('error', 'error');\n\t} else {\n\t\tconsole.log = function () { /* ignore */ };\n\t\tconsole.warn = function () { /* ignore */ };\n\t\tconsole.info = function () { /* ignore */ };\n\t\twrapConsoleMethod('error', 'error');\n\t}\n\n\twrapStream('stderr', 'error');\n\twrapStream('stdout', 'log');\n}\n\nfunction handleExceptions(): void {\n\n\t// Handle uncaught exceptions\n\tprocess.on('uncaughtException', function (err) {\n\t\tconsole.error('Uncaught Exception: ', err);\n\t});\n\n\t// Handle unhandled promise rejections\n\tprocess.on('unhandledRejection', function (reason) {\n\t\tconsole.error('Unhandled Promise Rejection: ', reason);\n\t});\n}\n\nfunction terminateWhenParentTerminates(): void {\n\tconst parentPid = Number(process.env['VSCODE_PARENT_PID']);\n\n\tif (typeof parentPid === 'number' && !isNaN(parentPid)) {\n\t\tsetInterval(function () {\n\t\t\ttry {\n\t\t\t\tprocess.kill(parentPid, 0); // throws an exception if the main process doesn't exist anymore.\n\t\t\t} catch (e) {\n\t\t\t\tprocess.exit();\n\t\t\t}\n\t\t}, 5000);\n\t}\n}\n\nfunction configureCrashReporter(): void {\n\tconst crashReporterProcessType = process.env['VSCODE_CRASH_REPORTER_PROCESS_TYPE'];\n\tif (crashReporterProcessType) {\n\t\ttry {\n\t\t\t//@ts-ignore\n\t\t\tif (process['crashReporter'] && typeof process['crashReporter'].addExtraParameter === 'function' /* Electron only */) {\n\t\t\t\t//@ts-ignore\n\t\t\t\tprocess['crashReporter'].addExtraParameter('processType', crashReporterProcessType);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\t}\n}\n\n//#endregion\n\n// Crash reporter\nconfigureCrashReporter();\n\n// Remove global paths from the node module lookup (node.js only)\nremoveGlobalNodeJsModuleLookupPaths();\n\nif (process.env['VSCODE_DEV_INJECT_NODE_MODULE_LOOKUP_PATH']) {\n\tdevInjectNodeModuleLookupPath(process.env['VSCODE_DEV_INJECT_NODE_MODULE_LOOKUP_PATH']);\n}\n\n// Configure: pipe logging to parent process\nif (!!process.send && process.env['VSCODE_PIPE_LOGGING'] === 'true') {\n\tpipeLoggingToParent();\n}\n\n// Handle Exceptions\nif (!process.env['VSCODE_HANDLES_UNCAUGHT_ERRORS']) {\n\thandleExceptions();\n}\n\n// Terminate when parent terminates\nif (process.env['VSCODE_PARENT_PID']) {\n\tterminateWhenParentTerminates();\n}\n\n// Bootstrap ESM\nawait bootstrapESM();\n\n// Load ESM entry point\nawait import([`./${process.env['VSCODE_ESM_ENTRYPOINT']}.js`].join('/') /* workaround: esbuild prints some strange warnings when trying to inline? */);\n",
    "contentHash": "d22748385c8256d7",
    "timestamp": 1757742740721
  },
  "/Users/simonvutov/Documents/vscode/src/bootstrap-meta.ts:level1": {
    "filePath": "/Users/simonvutov/Documents/vscode/src/bootstrap-meta.ts",
    "level": 1,
    "summary": "Abstraction level 1 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createRequire } from 'node:module';\nimport type { IProductConfiguration } from './vs/base/common/product.js';\n\nconst require = createRequire(import.meta.url);\n\nlet productObj: Partial<IProductConfiguration> & { BUILD_INSERT_PRODUCT_CONFIGURATION?: string } = { BUILD_INSERT_PRODUCT_CONFIGURATION: 'BUILD_INSERT_PRODUCT_CONFIGURATION' }; // DO NOT MODIFY, PATCHED DURING BUILD\nif (productObj['BUILD_INSERT_PRODUCT_CONFIGURATION']) {\n\tproductObj = require('../product.json'); // Running out of sources\n}\n\nlet pkgObj = { BUILD_INSERT_PACKAGE_CONFIGURATION: 'BUILD_INSERT_PACKAGE_CONFIGURATION' }; // DO NOT MODIFY, PATCHED DURING BUILD\nif (pkgObj['BUILD_INSERT_PACKAGE_CONFIGURATION']) {\n\tpkgObj = require('../package.json'); // Running out of sources\n}\n\nlet productOverridesObj = {};\nif (process.env['VSCODE_DEV']) {\n\ttry {\n\t\tproductOverridesObj = require('../product.overrides.json');\n\t\tproductObj = Object.assign(productObj, productOverridesObj);\n\t} catch (error) { /* ignore */ }\n}\n\nexport const product = productObj;\nexport const pkg = pkgObj;\n",
    "contentHash": "c6b1f161076c0b8c",
    "timestamp": 1757742743581
  },
  "/Users/simonvutov/Documents/vscode/src/bootstrap-import.ts:level1": {
    "filePath": "/Users/simonvutov/Documents/vscode/src/bootstrap-import.ts",
    "level": 1,
    "summary": "Abstraction level 1 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// *********************************************************************\n// *                                                                   *\n// *  We need this to redirect to node_modules from the remote-folder. *\n// *  This ONLY applies when running out of source.                   *\n// *                                                                   *\n// *********************************************************************\n\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport { promises } from 'node:fs';\nimport { join } from 'node:path';\n\n// SEE https://nodejs.org/docs/latest/api/module.html#initialize\n\nconst _specifierToUrl: Record<string, string> = {};\n\nexport async function initialize(injectPath: string): Promise<void> {\n\t// populate mappings\n\n\tconst injectPackageJSONPath = fileURLToPath(new URL('../package.json', pathToFileURL(injectPath)));\n\tconst packageJSON = JSON.parse(String(await promises.readFile(injectPackageJSONPath)));\n\n\tfor (const [name] of Object.entries(packageJSON.dependencies)) {\n\t\ttry {\n\t\t\tconst path = join(injectPackageJSONPath, `../node_modules/${name}/package.json`);\n\t\t\tlet { main } = JSON.parse(String(await promises.readFile(path)));\n\n\t\t\tif (!main) {\n\t\t\t\tmain = 'index.js';\n\t\t\t}\n\t\t\tif (!main.endsWith('.js')) {\n\t\t\t\tmain += '.js';\n\t\t\t}\n\t\t\tconst mainPath = join(injectPackageJSONPath, `../node_modules/${name}/${main}`);\n\t\t\t_specifierToUrl[name] = pathToFileURL(mainPath).href;\n\n\t\t} catch (err) {\n\t\t\tconsole.error(name);\n\t\t\tconsole.error(err);\n\t\t}\n\t}\n\n\tconsole.log(`[bootstrap-import] Initialized node_modules redirector for: ${injectPath}`);\n}\n\nexport async function resolve(specifier: string | number, context: any, nextResolve: (arg0: any, arg1: any) => any) {\n\n\tconst newSpecifier = _specifierToUrl[specifier];\n\tif (newSpecifier !== undefined) {\n\t\treturn {\n\t\t\tformat: 'commonjs',\n\t\t\tshortCircuit: true,\n\t\t\turl: newSpecifier\n\t\t};\n\t}\n\n\t// Defer to the next hook in the chain, which would be the\n\t// Node.js default resolve if this is the last user-specified loader.\n\treturn nextResolve(specifier, context);\n}\n",
    "contentHash": "b640370b92473b2a",
    "timestamp": 1757742745467
  },
  "/Users/simonvutov/Documents/vscode/src/bootstrap-server.ts:level1": {
    "filePath": "/Users/simonvutov/Documents/vscode/src/bootstrap-server.ts",
    "level": 1,
    "summary": "Abstraction level 1 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// Keep bootstrap-esm.js from redefining 'fs'.\ndelete process.env['ELECTRON_RUN_AS_NODE'];\n",
    "contentHash": "ea2ea1b70333cd39",
    "timestamp": 1757742762146
  },
  "/Users/simonvutov/Documents/vscode/src/bootstrap-server.ts:level4": {
    "filePath": "/Users/simonvutov/Documents/vscode/src/bootstrap-server.ts",
    "level": 4,
    "summary": "Abstraction level 4 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// Keep bootstrap-esm.js from redefining 'fs'.\ndelete process.env['ELECTRON_RUN_AS_NODE'];\n",
    "contentHash": "ea2ea1b70333cd39",
    "timestamp": 1757742765934
  }
}