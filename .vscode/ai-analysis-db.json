{
  "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts:level3": {
    "filePath": "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts",
    "level": 3,
    "summary": "Abstraction level 3 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport * as ts from 'typescript';\nimport * as path from 'path';\n\nexport async function activate(context: vscode.ExtensionContext) {\n\n\tconst fileIndex = new class {\n\n\t\tprivate _currentRun?: Thenable<void>;\n\n\t\tprivate _disposables: vscode.Disposable[] = [];\n\n\t\tprivate readonly _index = new Map<string, vscode.Uri>();\n\n\t\tconstructor() {\n\t\t\tconst watcher = vscode.workspace.createFileSystemWatcher('**/*.ts', false, true, false);\n\t\t\tthis._disposables.push(watcher.onDidChange(e => { this._index.set(e.toString(), e); }));\n\t\t\tthis._disposables.push(watcher.onDidDelete(e => { this._index.delete(e.toString()); }));\n\t\t\tthis._disposables.push(watcher);\n\n\t\t\tthis._refresh(false);\n\t\t}\n\n\t\tdispose(): void {\n\t\t\tfor (const disposable of this._disposables) {\n\t\t\t\tdisposable.dispose();\n\t\t\t}\n\t\t\tthis._disposables = [];\n\t\t\tthis._index.clear();\n\t\t}\n\n\t\tasync all(token: vscode.CancellationToken) {\n\n\t\t\tawait Promise.race([this._currentRun, new Promise<void>(resolve => token.onCancellationRequested(resolve))]);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn Array.from(this._index.values());\n\t\t}\n\n\t\tprivate _refresh(clear: boolean) {\n\t\t\t// TODO@jrieken LATEST API! findFiles2New\n\t\t\tthis._currentRun = vscode.workspace.findFiles('src/vs/**/*.ts', '{**/node_modules/**,**/extensions/**}').then(all => {\n\t\t\t\tif (clear) {\n\t\t\t\t\tthis._index.clear();\n\t\t\t\t}\n\t\t\t\tfor (const item of all) {\n\t\t\t\t\tthis._index.set(item.toString(), item);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst selector: vscode.DocumentSelector = 'typescript';\n\n\tfunction findNodeAtPosition(document: vscode.TextDocument, node: ts.Node, position: vscode.Position): ts.Node | undefined {\n\t\tif (node.getStart() <= document.offsetAt(position) && node.getEnd() >= document.offsetAt(position)) {\n\t\t\treturn ts.forEachChild(node, child => findNodeAtPosition(document, child, position)) || node;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction findImportAt(document: vscode.TextDocument, position: vscode.Position): ts.ImportDeclaration | undefined {\n\t\tconst sourceFile = ts.createSourceFile(document.fileName, document.getText(), ts.ScriptTarget.Latest, true);\n\t\tconst node = findNodeAtPosition(document, sourceFile, position);\n\t\tif (node && ts.isStringLiteral(node) && ts.isImportDeclaration(node.parent)) {\n\t\t\treturn node.parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tconst completionProvider = new class implements vscode.CompletionItemProvider {\n\t\tasync provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): Promise<vscode.CompletionList | undefined> {\n\n\t\t\tconst index = document.getText().lastIndexOf(' from \\'');\n\t\t\tif (index < 0 || document.positionAt(index).line < position.line) {\n\t\t\t\t// line after last import is before position\n\t\t\t\t// -> no completion, safe a parse call\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst node = findImportAt(document, position);\n\t\t\tif (!node) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst range = new vscode.Range(document.positionAt(node.moduleSpecifier.pos), document.positionAt(node.moduleSpecifier.end));\n\t\t\tconst uris = await fileIndex.all(token);\n\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CompletionList();\n\t\t\tresult.isIncomplete = true;\n\n\t\t\tfor (const item of uris) {\n\n\t\t\t\tif (!item.path.endsWith('.ts')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path);\n\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\tconst label = path.basename(item.path, path.extname(item.path));\n\t\t\t\tconst insertText = ` '${relativePath.replace(/\\.ts$/, '.js')}'`;\n\t\t\t\tconst filterText = ` '${label}'`;\n\n\t\t\t\tconst completion = new vscode.CompletionItem({\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tdescription: vscode.workspace.asRelativePath(item),\n\t\t\t\t});\n\t\t\t\tcompletion.kind = vscode.CompletionItemKind.File;\n\t\t\t\tcompletion.insertText = insertText;\n\t\t\t\tcompletion.filterText = filterText;\n\t\t\t\tcompletion.range = range;\n\n\t\t\t\tresult.items.push(completion);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tclass ImportCodeActions implements vscode.CodeActionProvider {\n\n\t\tstatic FixKind = vscode.CodeActionKind.QuickFix.append('esmImport');\n\n\t\tstatic SourceKind = vscode.CodeActionKind.SourceFixAll.append('esmImport');\n\n\t\tasync provideCodeActions(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tif (context.only && ImportCodeActions.SourceKind.intersects(context.only)) {\n\t\t\t\treturn this._provideFixAll(document, context, token);\n\t\t\t}\n\n\t\t\treturn this._provideFix(document, range, context, token);\n\t\t}\n\n\t\tprivate async _provideFixAll(document: vscode.TextDocument, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tconst diagnostics = context.diagnostics\n\t\t\t\t.filter(d => d.code === 2307)\n\t\t\t\t.sort((a, b) => b.range.start.compareTo(a.range.start));\n\n\t\t\tif (diagnostics.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CodeAction(`Fix All ESM Imports`, ImportCodeActions.SourceKind);\n\t\t\tresult.edit = new vscode.WorkspaceEdit();\n\t\t\tresult.diagnostics = [];\n\n\t\t\tfor (const diag of diagnostics) {\n\n\t\t\t\tconst actions = this._provideFixesForDiag(document, diag, uris);\n\n\t\t\t\tif (actions.length === 0) {\n\t\t\t\t\tconsole.log(`ESM: no fixes for \"${diag.message}\"`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (actions.length > 1) {\n\t\t\t\t\tconsole.log(`ESM: more than one fix for \"${diag.message}\", taking first`);\n\t\t\t\t\tconsole.log(actions);\n\t\t\t\t}\n\n\t\t\t\tconst [first] = actions;\n\t\t\t\tresult.diagnostics.push(diag);\n\n\t\t\t\tfor (const [uri, edits] of first.edit!.entries()) {\n\t\t\t\t\tresult.edit.set(uri, edits);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// console.log(result.edit.get(document.uri));\n\t\t\treturn [result];\n\t\t}\n\n\t\tprivate async _provideFix(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst diag = context.diagnostics.find(d => d.code === 2307 && d.range.intersection(range));\n\t\t\treturn diag && this._provideFixesForDiag(document, diag, uris);\n\t\t}\n\n\t\tprivate _provideFixesForDiag(document: vscode.TextDocument, diag: vscode.Diagnostic, uris: Iterable<vscode.Uri>): vscode.CodeAction[] {\n\n\t\t\tconst node = findImportAt(document, diag.range.start)?.moduleSpecifier;\n\t\t\tif (!node || !ts.isStringLiteral(node)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst nodeRange = new vscode.Range(document.positionAt(node.pos), document.positionAt(node.end));\n\t\t\tconst name = path.basename(node.text, path.extname(node.text));\n\n\t\t\tconst result: vscode.CodeAction[] = [];\n\n\t\t\tfor (const item of uris) {\n\t\t\t\tif (path.basename(item.path, path.extname(item.path)) === name) {\n\t\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path).replace(/\\.ts$/, '.js');\n\t\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\t\tconst action = new vscode.CodeAction(`Fix to '${relativePath}'`, ImportCodeActions.FixKind);\n\t\t\t\t\taction.edit = new vscode.WorkspaceEdit();\n\t\t\t\t\taction.edit.replace(document.uri, nodeRange, ` '${relativePath}'`);\n\t\t\t\t\taction.diagnostics = [diag];\n\t\t\t\t\tresult.push(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcontext.subscriptions.push(fileIndex);\n\tcontext.subscriptions.push(vscode.languages.registerCompletionItemProvider(selector, completionProvider));\n\tcontext.subscriptions.push(vscode.languages.registerCodeActionsProvider(selector, new ImportCodeActions(), { providedCodeActionKinds: [ImportCodeActions.FixKind, ImportCodeActions.SourceKind] }));\n}\n",
    "contentHash": "741e59394bfc5410",
    "timestamp": 1757742288666
  },
  "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts:level2": {
    "filePath": "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts",
    "level": 2,
    "summary": "Abstraction level 2 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport * as ts from 'typescript';\nimport * as path from 'path';\n\nexport async function activate(context: vscode.ExtensionContext) {\n\n\tconst fileIndex = new class {\n\n\t\tprivate _currentRun?: Thenable<void>;\n\n\t\tprivate _disposables: vscode.Disposable[] = [];\n\n\t\tprivate readonly _index = new Map<string, vscode.Uri>();\n\n\t\tconstructor() {\n\t\t\tconst watcher = vscode.workspace.createFileSystemWatcher('**/*.ts', false, true, false);\n\t\t\tthis._disposables.push(watcher.onDidChange(e => { this._index.set(e.toString(), e); }));\n\t\t\tthis._disposables.push(watcher.onDidDelete(e => { this._index.delete(e.toString()); }));\n\t\t\tthis._disposables.push(watcher);\n\n\t\t\tthis._refresh(false);\n\t\t}\n\n\t\tdispose(): void {\n\t\t\tfor (const disposable of this._disposables) {\n\t\t\t\tdisposable.dispose();\n\t\t\t}\n\t\t\tthis._disposables = [];\n\t\t\tthis._index.clear();\n\t\t}\n\n\t\tasync all(token: vscode.CancellationToken) {\n\n\t\t\tawait Promise.race([this._currentRun, new Promise<void>(resolve => token.onCancellationRequested(resolve))]);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn Array.from(this._index.values());\n\t\t}\n\n\t\tprivate _refresh(clear: boolean) {\n\t\t\t// TODO@jrieken LATEST API! findFiles2New\n\t\t\tthis._currentRun = vscode.workspace.findFiles('src/vs/**/*.ts', '{**/node_modules/**,**/extensions/**}').then(all => {\n\t\t\t\tif (clear) {\n\t\t\t\t\tthis._index.clear();\n\t\t\t\t}\n\t\t\t\tfor (const item of all) {\n\t\t\t\t\tthis._index.set(item.toString(), item);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst selector: vscode.DocumentSelector = 'typescript';\n\n\tfunction findNodeAtPosition(document: vscode.TextDocument, node: ts.Node, position: vscode.Position): ts.Node | undefined {\n\t\tif (node.getStart() <= document.offsetAt(position) && node.getEnd() >= document.offsetAt(position)) {\n\t\t\treturn ts.forEachChild(node, child => findNodeAtPosition(document, child, position)) || node;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction findImportAt(document: vscode.TextDocument, position: vscode.Position): ts.ImportDeclaration | undefined {\n\t\tconst sourceFile = ts.createSourceFile(document.fileName, document.getText(), ts.ScriptTarget.Latest, true);\n\t\tconst node = findNodeAtPosition(document, sourceFile, position);\n\t\tif (node && ts.isStringLiteral(node) && ts.isImportDeclaration(node.parent)) {\n\t\t\treturn node.parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tconst completionProvider = new class implements vscode.CompletionItemProvider {\n\t\tasync provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): Promise<vscode.CompletionList | undefined> {\n\n\t\t\tconst index = document.getText().lastIndexOf(' from \\'');\n\t\t\tif (index < 0 || document.positionAt(index).line < position.line) {\n\t\t\t\t// line after last import is before position\n\t\t\t\t// -> no completion, safe a parse call\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst node = findImportAt(document, position);\n\t\t\tif (!node) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst range = new vscode.Range(document.positionAt(node.moduleSpecifier.pos), document.positionAt(node.moduleSpecifier.end));\n\t\t\tconst uris = await fileIndex.all(token);\n\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CompletionList();\n\t\t\tresult.isIncomplete = true;\n\n\t\t\tfor (const item of uris) {\n\n\t\t\t\tif (!item.path.endsWith('.ts')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path);\n\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\tconst label = path.basename(item.path, path.extname(item.path));\n\t\t\t\tconst insertText = ` '${relativePath.replace(/\\.ts$/, '.js')}'`;\n\t\t\t\tconst filterText = ` '${label}'`;\n\n\t\t\t\tconst completion = new vscode.CompletionItem({\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tdescription: vscode.workspace.asRelativePath(item),\n\t\t\t\t});\n\t\t\t\tcompletion.kind = vscode.CompletionItemKind.File;\n\t\t\t\tcompletion.insertText = insertText;\n\t\t\t\tcompletion.filterText = filterText;\n\t\t\t\tcompletion.range = range;\n\n\t\t\t\tresult.items.push(completion);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tclass ImportCodeActions implements vscode.CodeActionProvider {\n\n\t\tstatic FixKind = vscode.CodeActionKind.QuickFix.append('esmImport');\n\n\t\tstatic SourceKind = vscode.CodeActionKind.SourceFixAll.append('esmImport');\n\n\t\tasync provideCodeActions(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tif (context.only && ImportCodeActions.SourceKind.intersects(context.only)) {\n\t\t\t\treturn this._provideFixAll(document, context, token);\n\t\t\t}\n\n\t\t\treturn this._provideFix(document, range, context, token);\n\t\t}\n\n\t\tprivate async _provideFixAll(document: vscode.TextDocument, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tconst diagnostics = context.diagnostics\n\t\t\t\t.filter(d => d.code === 2307)\n\t\t\t\t.sort((a, b) => b.range.start.compareTo(a.range.start));\n\n\t\t\tif (diagnostics.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CodeAction(`Fix All ESM Imports`, ImportCodeActions.SourceKind);\n\t\t\tresult.edit = new vscode.WorkspaceEdit();\n\t\t\tresult.diagnostics = [];\n\n\t\t\tfor (const diag of diagnostics) {\n\n\t\t\t\tconst actions = this._provideFixesForDiag(document, diag, uris);\n\n\t\t\t\tif (actions.length === 0) {\n\t\t\t\t\tconsole.log(`ESM: no fixes for \"${diag.message}\"`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (actions.length > 1) {\n\t\t\t\t\tconsole.log(`ESM: more than one fix for \"${diag.message}\", taking first`);\n\t\t\t\t\tconsole.log(actions);\n\t\t\t\t}\n\n\t\t\t\tconst [first] = actions;\n\t\t\t\tresult.diagnostics.push(diag);\n\n\t\t\t\tfor (const [uri, edits] of first.edit!.entries()) {\n\t\t\t\t\tresult.edit.set(uri, edits);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// console.log(result.edit.get(document.uri));\n\t\t\treturn [result];\n\t\t}\n\n\t\tprivate async _provideFix(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst diag = context.diagnostics.find(d => d.code === 2307 && d.range.intersection(range));\n\t\t\treturn diag && this._provideFixesForDiag(document, diag, uris);\n\t\t}\n\n\t\tprivate _provideFixesForDiag(document: vscode.TextDocument, diag: vscode.Diagnostic, uris: Iterable<vscode.Uri>): vscode.CodeAction[] {\n\n\t\t\tconst node = findImportAt(document, diag.range.start)?.moduleSpecifier;\n\t\t\tif (!node || !ts.isStringLiteral(node)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst nodeRange = new vscode.Range(document.positionAt(node.pos), document.positionAt(node.end));\n\t\t\tconst name = path.basename(node.text, path.extname(node.text));\n\n\t\t\tconst result: vscode.CodeAction[] = [];\n\n\t\t\tfor (const item of uris) {\n\t\t\t\tif (path.basename(item.path, path.extname(item.path)) === name) {\n\t\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path).replace(/\\.ts$/, '.js');\n\t\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\t\tconst action = new vscode.CodeAction(`Fix to '${relativePath}'`, ImportCodeActions.FixKind);\n\t\t\t\t\taction.edit = new vscode.WorkspaceEdit();\n\t\t\t\t\taction.edit.replace(document.uri, nodeRange, ` '${relativePath}'`);\n\t\t\t\t\taction.diagnostics = [diag];\n\t\t\t\t\tresult.push(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcontext.subscriptions.push(fileIndex);\n\tcontext.subscriptions.push(vscode.languages.registerCompletionItemProvider(selector, completionProvider));\n\tcontext.subscriptions.push(vscode.languages.registerCodeActionsProvider(selector, new ImportCodeActions(), { providedCodeActionKinds: [ImportCodeActions.FixKind, ImportCodeActions.SourceKind] }));\n}\n",
    "contentHash": "741e59394bfc5410",
    "timestamp": 1757742295165
  },
  "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts:level4": {
    "filePath": "/Users/simonvutov/Documents/vscode/.vscode/extensions/vscode-selfhost-import-aid/src/extension.ts",
    "level": 4,
    "summary": "Abstraction level 4 + /*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as vscode from 'vscode';\nimport * as ts from 'typescript';\nimport * as path from 'path';\n\nexport async function activate(context: vscode.ExtensionContext) {\n\n\tconst fileIndex = new class {\n\n\t\tprivate _currentRun?: Thenable<void>;\n\n\t\tprivate _disposables: vscode.Disposable[] = [];\n\n\t\tprivate readonly _index = new Map<string, vscode.Uri>();\n\n\t\tconstructor() {\n\t\t\tconst watcher = vscode.workspace.createFileSystemWatcher('**/*.ts', false, true, false);\n\t\t\tthis._disposables.push(watcher.onDidChange(e => { this._index.set(e.toString(), e); }));\n\t\t\tthis._disposables.push(watcher.onDidDelete(e => { this._index.delete(e.toString()); }));\n\t\t\tthis._disposables.push(watcher);\n\n\t\t\tthis._refresh(false);\n\t\t}\n\n\t\tdispose(): void {\n\t\t\tfor (const disposable of this._disposables) {\n\t\t\t\tdisposable.dispose();\n\t\t\t}\n\t\t\tthis._disposables = [];\n\t\t\tthis._index.clear();\n\t\t}\n\n\t\tasync all(token: vscode.CancellationToken) {\n\n\t\t\tawait Promise.race([this._currentRun, new Promise<void>(resolve => token.onCancellationRequested(resolve))]);\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn Array.from(this._index.values());\n\t\t}\n\n\t\tprivate _refresh(clear: boolean) {\n\t\t\t// TODO@jrieken LATEST API! findFiles2New\n\t\t\tthis._currentRun = vscode.workspace.findFiles('src/vs/**/*.ts', '{**/node_modules/**,**/extensions/**}').then(all => {\n\t\t\t\tif (clear) {\n\t\t\t\t\tthis._index.clear();\n\t\t\t\t}\n\t\t\t\tfor (const item of all) {\n\t\t\t\t\tthis._index.set(item.toString(), item);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst selector: vscode.DocumentSelector = 'typescript';\n\n\tfunction findNodeAtPosition(document: vscode.TextDocument, node: ts.Node, position: vscode.Position): ts.Node | undefined {\n\t\tif (node.getStart() <= document.offsetAt(position) && node.getEnd() >= document.offsetAt(position)) {\n\t\t\treturn ts.forEachChild(node, child => findNodeAtPosition(document, child, position)) || node;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction findImportAt(document: vscode.TextDocument, position: vscode.Position): ts.ImportDeclaration | undefined {\n\t\tconst sourceFile = ts.createSourceFile(document.fileName, document.getText(), ts.ScriptTarget.Latest, true);\n\t\tconst node = findNodeAtPosition(document, sourceFile, position);\n\t\tif (node && ts.isStringLiteral(node) && ts.isImportDeclaration(node.parent)) {\n\t\t\treturn node.parent;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tconst completionProvider = new class implements vscode.CompletionItemProvider {\n\t\tasync provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): Promise<vscode.CompletionList | undefined> {\n\n\t\t\tconst index = document.getText().lastIndexOf(' from \\'');\n\t\t\tif (index < 0 || document.positionAt(index).line < position.line) {\n\t\t\t\t// line after last import is before position\n\t\t\t\t// -> no completion, safe a parse call\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst node = findImportAt(document, position);\n\t\t\tif (!node) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst range = new vscode.Range(document.positionAt(node.moduleSpecifier.pos), document.positionAt(node.moduleSpecifier.end));\n\t\t\tconst uris = await fileIndex.all(token);\n\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CompletionList();\n\t\t\tresult.isIncomplete = true;\n\n\t\t\tfor (const item of uris) {\n\n\t\t\t\tif (!item.path.endsWith('.ts')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path);\n\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\tconst label = path.basename(item.path, path.extname(item.path));\n\t\t\t\tconst insertText = ` '${relativePath.replace(/\\.ts$/, '.js')}'`;\n\t\t\t\tconst filterText = ` '${label}'`;\n\n\t\t\t\tconst completion = new vscode.CompletionItem({\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tdescription: vscode.workspace.asRelativePath(item),\n\t\t\t\t});\n\t\t\t\tcompletion.kind = vscode.CompletionItemKind.File;\n\t\t\t\tcompletion.insertText = insertText;\n\t\t\t\tcompletion.filterText = filterText;\n\t\t\t\tcompletion.range = range;\n\n\t\t\t\tresult.items.push(completion);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tclass ImportCodeActions implements vscode.CodeActionProvider {\n\n\t\tstatic FixKind = vscode.CodeActionKind.QuickFix.append('esmImport');\n\n\t\tstatic SourceKind = vscode.CodeActionKind.SourceFixAll.append('esmImport');\n\n\t\tasync provideCodeActions(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tif (context.only && ImportCodeActions.SourceKind.intersects(context.only)) {\n\t\t\t\treturn this._provideFixAll(document, context, token);\n\t\t\t}\n\n\t\t\treturn this._provideFix(document, range, context, token);\n\t\t}\n\n\t\tprivate async _provideFixAll(document: vscode.TextDocument, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\n\t\t\tconst diagnostics = context.diagnostics\n\t\t\t\t.filter(d => d.code === 2307)\n\t\t\t\t.sort((a, b) => b.range.start.compareTo(a.range.start));\n\n\t\t\tif (diagnostics.length === 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst result = new vscode.CodeAction(`Fix All ESM Imports`, ImportCodeActions.SourceKind);\n\t\t\tresult.edit = new vscode.WorkspaceEdit();\n\t\t\tresult.diagnostics = [];\n\n\t\t\tfor (const diag of diagnostics) {\n\n\t\t\t\tconst actions = this._provideFixesForDiag(document, diag, uris);\n\n\t\t\t\tif (actions.length === 0) {\n\t\t\t\t\tconsole.log(`ESM: no fixes for \"${diag.message}\"`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (actions.length > 1) {\n\t\t\t\t\tconsole.log(`ESM: more than one fix for \"${diag.message}\", taking first`);\n\t\t\t\t\tconsole.log(actions);\n\t\t\t\t}\n\n\t\t\t\tconst [first] = actions;\n\t\t\t\tresult.diagnostics.push(diag);\n\n\t\t\t\tfor (const [uri, edits] of first.edit!.entries()) {\n\t\t\t\t\tresult.edit.set(uri, edits);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// console.log(result.edit.get(document.uri));\n\t\t\treturn [result];\n\t\t}\n\n\t\tprivate async _provideFix(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): Promise<vscode.CodeAction[] | undefined> {\n\t\t\tconst uris = await fileIndex.all(token);\n\t\t\tif (!uris) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst diag = context.diagnostics.find(d => d.code === 2307 && d.range.intersection(range));\n\t\t\treturn diag && this._provideFixesForDiag(document, diag, uris);\n\t\t}\n\n\t\tprivate _provideFixesForDiag(document: vscode.TextDocument, diag: vscode.Diagnostic, uris: Iterable<vscode.Uri>): vscode.CodeAction[] {\n\n\t\t\tconst node = findImportAt(document, diag.range.start)?.moduleSpecifier;\n\t\t\tif (!node || !ts.isStringLiteral(node)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst nodeRange = new vscode.Range(document.positionAt(node.pos), document.positionAt(node.end));\n\t\t\tconst name = path.basename(node.text, path.extname(node.text));\n\n\t\t\tconst result: vscode.CodeAction[] = [];\n\n\t\t\tfor (const item of uris) {\n\t\t\t\tif (path.basename(item.path, path.extname(item.path)) === name) {\n\t\t\t\t\tlet relativePath = path.relative(path.dirname(document.uri.path), item.path).replace(/\\.ts$/, '.js');\n\t\t\t\t\trelativePath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;\n\n\t\t\t\t\tconst action = new vscode.CodeAction(`Fix to '${relativePath}'`, ImportCodeActions.FixKind);\n\t\t\t\t\taction.edit = new vscode.WorkspaceEdit();\n\t\t\t\t\taction.edit.replace(document.uri, nodeRange, ` '${relativePath}'`);\n\t\t\t\t\taction.diagnostics = [diag];\n\t\t\t\t\tresult.push(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcontext.subscriptions.push(fileIndex);\n\tcontext.subscriptions.push(vscode.languages.registerCompletionItemProvider(selector, completionProvider));\n\tcontext.subscriptions.push(vscode.languages.registerCodeActionsProvider(selector, new ImportCodeActions(), { providedCodeActionKinds: [ImportCodeActions.FixKind, ImportCodeActions.SourceKind] }));\n}\n",
    "contentHash": "741e59394bfc5410",
    "timestamp": 1757742301554
  }
}